       /*
        기본적인 변수 선언

        int n = 15;     // 십진수 15
        int m = 015;    // 8진수 13
        int k = 0x15;   // 16진수 21
        int l = 0b0101; // 2진수 5

        long lk = 150l;
        String kor = null; // String 은 객체이므로 null이 할당가능하다.

        */


        /* 조건 연산자
        * 조건 연산자는 3개의 피연산자로 구성되어 삼항 연산자라고도 한다.
        * 형식 *

         condition ? opr2 : opr3





        int x = 5;
        int y = 3;
        int s = (x>y) ? 1:-2; // x > y 이므로 1이 s에 할당된다

        System.out.println(s); // 1이 출력됨
        */

        /* 비트 연산
        컴퓨터는 모든 정보를 0과 1값만 가지는 2진수로 저장한다.

        여기서 2진수의 한 자리를 비트 bit 라고 부르며, 8 비트를 1byte라고 한다.

        십진수 10을 한 바이트로 표현하면 00001010이다.
        */

        /*  byte flag; //byte의 8개의 각 비트는 8개의 센서 값을 각각 가리킨다.

        if(flag & 0b00001000 ==0) System.out.println("온도는 0도 이하");
        else System.out.println("온도는 0도 이상"); */

        /* 비트 시프트 연산
        byte a = 5; //0b00000101 로 저장됨
        byte b = (byte) (a << 2); // a 값을 왼쪽으로 2비트만큼 이동.
        // 즉 0b00000101 > 0b00010100
        // >> 와 <<는 1비트씩 시프트 할 때마다 나누기2 / 곱하기 2의 효과가 각각 나타난다.

        // 논리적 오른쪽 시프트
        byte x = 20; // 20 할당
        byte y = (byte)(x >>> 2);

        System.out.println(b); // 20이 출력됨
        System.out.println(y); // 0b00010100 -> 0b00000101  => 5

        //산술적 오른쪽 시프트
        byte k = (byte) 0xf8; // 1111 1000

        // 2의 보수 표현법 공부하기

         */

        // 배열 //
        /* 배열은 인덱스와 인덱스에 대응하는 데이터들로 이루어진 연속적인 자료 구조로서, 같은 종류의 데이터들이 순차적으로 저장된다.

        선언하는 형식은 아래와 같다.

        int i [] = new int[10];

        세부적으로 살펴보면 자바에서 배열의 생성은 두 단계로 이루어진다.
        1. 배열에 대한 레퍼런스 변수 선언
        2. 배열 생성 - 배열의 저장 공간 할당

        1 -> int intArray [];에서
        int 배열의 타입 지정
        intArray 배열에 대한 레퍼런스 변수 지정
        [] 배열 선언을 의미한다.

        2-> intArray = new int [5];에서
        intArray 배열에 대한 레퍼런스 변수
        new 배열 생성
        int 타입
        [5] 원소 갯수를 의미한다. */

        /*   다차원 배열

        자바에서는 여러 차월의 배열을 만들 수 있다.

        3차원 이상의 배열은 특별한 경우에만 사용한다.

        자바의 배열은 C/C++ 과는 다른 독특한 구조를 가진다.


        * 2차원 배열 *

        1. 선언과 생성

        1차월 배열과 마찬가지로 2차원 배열에서도 레퍼런스 변수 선언 후 배열을 생성한다.

        int intArray [][];
        char charArray [][];

        int [][] intArray;
        char [][] charArray;

        위와 같이 2가지 방법으로 2차원 배열을 생성할 수 있다.

        -- 저장공간 생성 --

        int [][] intArray = new int [2][5]; -> 2 x 5 의 배열 구조를 갖는다.
        [2] -> 행을 의미 [5] -> 열을 의미한다.

        위와 같이 저장공간을 생성하는 것은 1차원 배열과 크게 다르지 않음을 볼 수 있다.

        배열에서의 length 의미를 알아보자

        int [][] intArray = new int [2][5] ; => 해당 코드와 같이 선언과 동시에 생성도 가능

        intArray.length -> 2
        intArray[0].length -> 5
        intArray[1].length -> 5

        -- 2차원 배열의 초기화 --

        아래와 같이 2차원 배열을 선언할 때 각 원소를 초기화 할 수 있다.
        그러면 자동으로 원소 개수만한 배열 공간이 할당되고, 원소 값으로 초기화한다.

        int intArray[][] = { {0,1,2} , {3,4,5} , {6,7,8} };  //  3 x 3의 배열이 생성됨
        char [][] charArray = { {'a','b', 'c'}, {'d','e','f'} } // 2 x 3의 배열이 생성됨

        -- 비정방형 배열 --

        정방형 배열은 행과 열의 갯수가 같은 모두 동일한 배열이다.

        이와 반대로 비정방형 배열은 행마다 열의 개수가 서로 다른 배열을 말한다.

        ex)
        int [][] intArray = new int [4][];

        intArray[0] = new int[3];
        intArray[1] = new int[4];
        intArray[2] = new int[1];  ...

        위와 같이 비정방형 배열이 생성 가능하다.

        -- 메소드에서의 배열 리턴 --

        먼저 메소드에서는 어떤 배열이든지 리턴하면 배열에 대한 레퍼런스만 리턴된다.



       -- main() 메소드 --

       main 메소드는 자바 응용프로그램의 실행이 시작되는 특별한 메소드로 원형은 아래와 같다.

       public static void main(String[] args){}

       public -> 다른 클래스에서 메소드 접근 허용

       * 자바 응용프로그램이 시작할 때 자바 가상 기계(JVM)에 의해 호출되어야 하므로 public 속성으로 선언되어야 한다.

       static -> 객체 생성 전부터 호출이 가능

       * 자신을 포함하는 클래스의 객체가 생성되기 전에, 처음부터 자바 가상 기계에 의해 호출이 되므로 static 속성이 선언되어야 한다.

       void -> 리턴 값 없음

       * 아무 값도 리턴하지 않기 때문에 void 타입이다. main() 메소드를 끝내기 위해 리턴하려면 return ; 하면 된다.

       String[] args 문자열 배열을 매개변수로 받음

       * 자바는 명령행에 입력된 인자들을 문자열 배열로 만들어 main() 메소드에 전달한다.

       -- main() 메소드의 매개변수 --

       자바에서 main() 메소드의 매개변수에 어떤 값이 어떻게 전달되는 지 알아보자.

       다음은 Hello 클래스를 실행하는 명령의 사례

       C:\> java Hello option1 option2 option3 ... -> Hello 클래스의 main() 에서 실행 시작됨

       option 1 ~ option ... 까지는 명령행 인자라고 부르며 이들은 모두 Hello 클래스의 main() 메소드의 매개변수로 전달된다.

       Hello 클래스의 main() 메소드가 시작되기 전, 이 인자들은 각각 문자열로 만들어지고 문자열 배열에 저장된다.

       ex)

       C\> java Hello 3 5 7

       ->
       class Hello{

       public static void main(String[] args){ }  args를 "3","5","7" 을 받아 크기 3의 배열이 초기화되어 생성된다.

       }

       --자바의 예외 처리 --
        자바의 예외처리는 아래와 같은 상황에서 발생할 수 있다.
        * 정수를 0으로 나누는 경우
        * 배열의 크기보다 큰 인덱스로 배열의 원소를 접근하는 경우
        * 존재하지 않는 파일을 읽으려고 하는 경우
        * 정수 입력을 기다리는 코드가 실행되고 있을 때, 사용자가 문자를 입력한 경우

        사례를 보자. to. exception_practice.java 파일로

        -- 클래스와 객체 --
        Class_prctice.java 파일로 실행

        먼저 객체에 대해서 설명해야겠다.
        객체란?
        컴퓨터 과학에서 객체 또는 오브젝트는 클래스에서 정의한 것을 토대로 메모리에 할당된 것으로 프로그램에서 사용되는 데이터 또는 식별자에 의해 참조되는 공간을 의미한다.

        자바는 객체지향 언어로 객체지향의 특성을 설명한다.

        1. 캡슐화
        -> 객체를 캡슈롤 싸서 내부를 보호하고 볼 수 없게 하는 것으로 객체의 가장 본질적인 특징이다.
        자바에서 객체는 클래스라는 캡슐을 사용하며, 필드와 메소드로 구성된다.

        2. 상속
        상속은 상위 개체의 속성이 하위 개체에 물려져서, 하위 개체가 상위 개체의 속성을 모두 가지는 관계이다.

        자바에서의 상속은 자식 클래스가 부모  클래스의 속성을 무려받고 기능을 추가하여 확장하는 개념이다.
        부모 클래스를 슈퍼클래스라고 하며 자식 클래스를 서브 클래스라고 부른다.

        3. 다형성
        -> 같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 동작하도록 구현되는 것을 말한다.
        ex> Animal 이르는 슈퍼 클래스를 상속받고 소리내기 speak()라는 메소드를 각각 다르게 개 , 고양이, 닭 클래스에 구현하였다.

        이때 서브 클래스에서 동일한 이름으로 자신의 특징에 맞게 다시 구현하는 것을 '메소드 오버라이딩'이라고 한다.

        다형성의 또 다른 사례는 클래스 내에서 이름이 같지만 서로 다르게 동작하는 메소드를
        여러 개 만드는 '메소드 오버로딩'도 있다.

        -- 객체 지향의 목적 --

        1. 소프트웨어 생산성 향상
        소프트웨어의 재사용을 위한 여러 기법들을 가진 객체 지향 언어

        2. 실세계에 대한 쉬운 모델링

        클래스와 객체의 차이점
        클래스는 객체를 만들어 내기 위한 설계도 혹은 틀이며, 클래스 모양 그대로 생성된 실체가 객체이다.

        객체를 클래스의 "인트턴스" 라고도 부른다

        클래스는 크게 이렇게 구성된다.

        public class Circle{
        접근 권한 /  클래스 선언 / 클래스 이름
        필드 (변수) 영역

        메소드 영역

        public Circle(){} // Circle 메소드의 생성자
        생성자 -> 클래스의 이름과 동일한 메소드를 특별히 생성자라고 한다.
        생성자 객체가 생성될 때 자동으로 호출되는 특별한 메소드이다.

        }

        생성자는 객체가 생성될 때 객체의 초기화를 위해 실행되는 메소드이다.

        생성자는 객체가 생성되는 순간에 자동으로 호출되는 메소드로서, 객체에 필요한 초기화를 실행하는 코드를 담아야 한다.
        ex)
        public Circle(int i, String n){
        this.변수 = i; this.변수=n;
        }

        생성자 특징
        1. 생성자의 이름은 클래스 이름과 동일하다.
        2. 생성자는 여러 개 작성 즉 오버로딩 할 수 있다.
        3. 생성자는 new를 통해 객체를 생성할 때 한 번만 호출된다.
        4. 생성자에 리턴 타입을 지정할 수 없다.
        5. 생성자의 목적은 객체가 생성될 때, 필요한 초기 작업을 위함이다.

        기본생성자란 매개변수와 실행 코드가 없어 아무 일도 하지 않고 단순 리턴하는 생성자이다.
        '디폴트 생성자'라고도 부른다





